{"id": "d1b19ba6-b05d-4254-8fa8-2f4495d4e1ce", "code": "# initial_program.py\nimport math\nimport random\n\n# Parametric family factory: returns a function f(x) built from parameters.\n# Candidate modules can either provide `params` (dict) or a function `f(x, **kwargs)`.\ndef build_parametric_f(params):\n    # params expected keys: \"type\" and numeric parameters\n    t = params.get(\"type\", \"supergauss\")\n    if t == \"supergauss\":\n        a = float(params.get(\"a\", 1.0))\n        p = float(params.get(\"p\", 4.0))   # p=2 is Gaussian, p>2 super-gauss\n        def f(x):\n            # Ensure a is not zero to avoid division by zero, use max for numerical stability\n            safe_a = max(a, 1e-9)\n            # Cap the exponent to prevent overflow for large x or large p\n            exponent = (abs(x)/safe_a)**p\n            return math.exp(-min(exponent, 700))\n        return f\n    elif t == \"lorentz\":\n        b = float(params.get(\"b\", 1.0))\n        # Ensure b is not zero to avoid division by zero, use max for numerical stability\n        safe_b = max(b, 1e-9)\n        def f(x):\n            return 1.0 / (1.0 + (x/safe_b)**2)\n        return f\n    elif t == \"mixed\":\n        a = float(params.get(\"a\", 1.0))\n        r = float(params.get(\"r\", 0.5))\n        # Ensure a is not zero to avoid division by zero, use max for numerical stability\n        safe_a = max(a, 1e-9)\n        def f(x):\n            # Ensure denominator in lorentz part is not zero, use max for numerical stability\n            safe_lorentz_denom = max(1.0 + x*x, 1e-9)\n            # Cap the exponent to prevent overflow\n            gaussian_term = (1-r)*math.exp(-min(safe_a*x*x, 700))\n            return gaussian_term + r/(safe_lorentz_denom)\n        return f\n    else:\n        # fallback safe Gaussian\n        a = float(params.get(\"a\", 1.0))\n        # Ensure a is not zero to avoid division by zero, use max for numerical stability\n        safe_a = max(a, 1e-9)\n        def f(x):\n            return math.exp(-safe_a*x*x)\n        return f\n\n# This search_algorithm returns a small parameter dictionary.\ndef search_algorithm():\n    # Provide a diverse starting sample (avoid p=2 exactly to not be Gaussian-first)\n    seed_types = [\"supergauss\", \"lorentz\", \"mixed\"]\n    choice = random.choice(seed_types)\n    if choice == \"supergauss\":\n        # Mutate 'a' slightly and 'p' to a value slightly larger than 2, with a focus on p > 2\n        params = {\"type\":\"supergauss\", \"a\": random.uniform(0.8, 1.2), \"p\": random.uniform(2.2, 4.8)}\n    elif choice == \"lorentz\":\n        # Mutate 'b' slightly, ensuring it remains positive and not too close to zero\n        params = {\"type\":\"lorentz\", \"b\": random.uniform(0.8, 1.2)}\n    else:\n        # Mutate 'a' and 'r' slightly, ensuring 'r' is not too close to 0 or 1\n        params = {\"type\":\"mixed\", \"a\": random.uniform(0.8, 1.2), \"r\": random.uniform(0.45, 0.55)}\n    # OpenEvolve can mutate the `params` dict or replace it with other dicts. Return it.\n    return params", "language": "python", "parent_id": "1fb9f3e2-36e1-420a-a9e4-debc9b5466d0", "generation": 3, "timestamp": 1763629577.637386, "iteration_found": 18, "metrics": {"error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"error": 0.0}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert in functional analysis and numerical methods.\nProduce small, numerically-safe mutations of the candidate returned by search_algorithm().\nPrefer parameter changes (modify numeric values in the params dict or tweak small constants).\nDo NOT output code that divides by zero or returns NaN/Inf, and do not use heavy Monte-Carlo loops.\nWhen proposing new candidates, either:\n  - return a modified params dictionary (e.g., {\"type\":\"supergauss\",\"a\":1.2,\"p\":4.0}), OR\n  - provide a short, valid Python function f(x) that evaluates safely on [-6,6].\nIMPORTANT:\n  - Always return ONLY executable Python code.\n  - Do not return text explanations, comments, or natural language.\n", "user": "# Current Program Information\n- Fitness: 0.0000\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.0000\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: error: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: error: 0.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: error: 0.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0000)\n```python\n# initial_program.py\nimport math\nimport random\n\n# Parametric family factory: returns a function f(x) built from parameters.\n# Candidate modules can either provide `params` (dict) or a function `f(x, **kwargs)`.\ndef build_parametric_f(params):\n    # params expected keys: \"type\" and numeric parameters\n    t = params.get(\"type\", \"supergauss\")\n    if t == \"supergauss\":\n        a = float(params.get(\"a\", 1.0))\n        p = float(params.get(\"p\", 4.0))   # p=2 is Gaussian, p>2 super-gauss\n        def f(x):\n            # Ensure a is not zero to avoid division by zero, use max for numerical stability\n            safe_a = max(a, 1e-9)\n            return math.exp(- (abs(x)/safe_a)**p )\n        return f\n    elif t == \"lorentz\":\n        b = float(params.get(\"b\", 1.0))\n        # Ensure b is not zero to avoid division by zero, use max for numerical stability\n        safe_b = max(b, 1e-9)\n        def f(x):\n            return 1.0 / (1.0 + (x/safe_b)**2)\n        return f\n    elif t == \"mixed\":\n        a = float(params.get(\"a\", 1.0))\n        r = float(params.get(\"r\", 0.5))\n        # Ensure a is not zero to avoid division by zero, use max for numerical stability\n        safe_a = max(a, 1e-9)\n        def f(x):\n            # Ensure denominator in lorentz part is not zero, use max for numerical stability\n            safe_lorentz_denom = max(1.0 + x*x, 1e-9)\n            return (1-r)*math.exp(-safe_a*x*x) + r/(safe_lorentz_denom)\n        return f\n    else:\n        # fallback safe Gaussian\n        a = float(params.get(\"a\", 1.0))\n        # Ensure a is not zero to avoid division by zero, use max for numerical stability\n        safe_a = max(a, 1e-9)\n        def f(x):\n            return math.exp(-safe_a*x*x)\n        return f\n\n# This search_algorithm returns a small parameter dictionary.\ndef search_algorithm():\n    # Provide a diverse starting sample (avoid p=2 exactly to not be Gaussian-first)\n    seed_types = [\"supergauss\", \"lorentz\", \"mixed\"]\n    choice = random.choice(seed_types)\n    if choice == \"supergauss\":\n        # Mutate 'a' slightly and 'p' to a value slightly larger than 2\n        params = {\"type\":\"supergauss\", \"a\": random.uniform(0.7, 1.3), \"p\": random.uniform(2.1, 5.0)}\n    elif choice == \"lorentz\":\n        # Mutate 'b' slightly\n        params = {\"type\":\"lorentz\", \"b\": random.uniform(0.7, 1.3)}\n    else:\n        # Mutate 'a' and 'r' slightly\n        params = {\"type\":\"mixed\", \"a\": random.uniform(0.7, 1.3), \"r\": random.uniform(0.4, 0.6)}\n    # OpenEvolve can mutate the `params` dict or replace it with other dicts. Return it.\n    return params\n```\nKey features: Performs well on error (0.0000)\n\n### Program 2 (Score: 0.0000)\n```python\n# initial_program.py\nimport math\nimport random\n\n# Parametric family factory: returns a function f(x) built from parameters.\n# Candidate modules can either provide `params` (dict) or a function `f(x, **kwargs)`.\ndef build_parametric_f(params):\n    # params expected keys: \"type\" and numeric parameters\n    t = params.get(\"type\", \"supergauss\")\n    if t == \"supergauss\":\n        a = float(params.get(\"a\", 1.0))\n        p = float(params.get(\"p\", 4.0))   # p=2 is Gaussian, p>2 super-gauss\n        def f(x):\n            # Ensure a is not zero to avoid division by zero and p is positive\n            safe_a = max(a, 1e-9)\n            safe_p = max(p, 1e-9)\n            return math.exp(- (abs(x)/safe_a)**safe_p )\n        return f\n    elif t == \"lorentz\":\n        b = float(params.get(\"b\", 1.0))\n        def f(x):\n            # Ensure b is not zero to avoid division by zero\n            safe_b = max(b, 1e-9)\n            return 1.0 / (1.0 + (x/safe_b)**2)\n        return f\n    elif t == \"mixed\":\n        a = float(params.get(\"a\", 1.0))\n        r = float(params.get(\"r\", 0.5))\n        def f(x):\n            # Ensure a is not zero\n            safe_a = max(a, 1e-9)\n            # Ensure denominator in lorentz part is not zero\n            safe_lorentz_denom = max(1.0 + x*x, 1e-9)\n            return (1-r)*math.exp(-safe_a*x*x) + r/(safe_lorentz_denom)\n        return f\n    else:\n        # fallback safe Gaussian\n        a = float(params.get(\"a\", 1.0))\n        def f(x):\n            # Ensure a is not zero\n            safe_a = max(a, 1e-9)\n            return math.exp(-safe_a*x*x)\n        return f\n\n# This search_algorithm returns a small parameter dictionary.\ndef search_algorithm():\n    # Provide a diverse starting sample (avoid p=2 exactly to not be Gaussian-first)\n    seed_types = [\"supergauss\", \"lorentz\", \"mixed\"]\n    choice = random.choice(seed_types)\n    if choice == \"supergauss\":\n        # Mutate 'a' to be slightly larger and 'p' to be slightly smaller but still > 2\n        # Also ensure 'p' is not too close to 2 to maintain super-gauss character\n        params = {\"type\":\"supergauss\", \"a\": random.uniform(0.9, 1.4), \"p\": random.uniform(2.2, 4.5)}\n    elif choice == \"lorentz\":\n        # Mutate 'b' to be slightly smaller, but not too small to avoid sharp peaks\n        params = {\"type\":\"lorentz\", \"b\": random.uniform(0.3, 1.2)}\n    else:\n        # Mutate 'a' to be slightly smaller and 'r' to be closer to 0.5\n        # Ensure 'a' is not too small and 'r' stays within reasonable bounds for mixing\n        params = {\"type\":\"mixed\", \"a\": random.uniform(0.4, 1.0), \"r\": random.uniform(0.45, 0.55)}\n    # OpenEvolve can mutate the `params` dict or replace it with other dicts. Return it.\n    return params\n```\nKey features: Performs well on error (0.0000)\n\n### Program 3 (Score: 0.0000)\n```python\n# initial_program.py\nimport math\nimport random\n\n# Parametric family factory: returns a function f(x) built from parameters.\n# Candidate modules can either provide `params` (dict) or a function `f(x, **kwargs)`.\ndef build_parametric_f(params):\n    # params expected keys: \"type\" and numeric parameters\n    t = params.get(\"type\", \"supergauss\")\n    if t == \"supergauss\":\n        a = float(params.get(\"a\", 1.0))\n        p = float(params.get(\"p\", 4.0))   # p=2 is Gaussian, p>2 super-gauss\n        def f(x):\n            # Ensure a is not zero to prevent division by zero\n            safe_a = max(a, 1e-9)\n            # Ensure the exponent doesn't become too large for large x\n            exponent = (abs(x)/safe_a)**p\n            return math.exp(-min(exponent, 700)) # Cap exponent to avoid overflow\n        return f\n    elif t == \"lorentz\":\n        b = float(params.get(\"b\", 1.0))\n        # Ensure b is not zero to prevent division by zero\n        safe_b = max(b, 1e-9)\n        def f(x):\n            return 1.0 / (1.0 + (x/safe_b)**2)\n        return f\n    elif t == \"mixed\":\n        a = float(params.get(\"a\", 1.0))\n        r = float(params.get(\"r\", 0.5))\n        # Ensure a is not zero\n        safe_a = max(a, 1e-9)\n        def f(x):\n            # Ensure the exponent doesn't become too large for large x\n            gaussian_term = (1-r)*math.exp(-min(safe_a*x*x, 700))\n            lorentz_term = r/(1.0 + x*x)\n            return gaussian_term + lorentz_term\n        return f\n    else:\n        # fallback safe Gaussian\n        a = float(params.get(\"a\", 1.0))\n        # Ensure a is not zero\n        safe_a = max(a, 1e-9)\n        def f(x):\n            return math.exp(-safe_a*x*x)\n        return f\n\n# This search_algorithm returns a small parameter dictionary.\ndef search_algorithm():\n    # Provide a diverse starting sample (avoid p=2 exactly to not be Gaussian-first)\n    seed_types = [\"supergauss\", \"lorentz\", \"mixed\"]\n    choice = random.choice(seed_types)\n    if choice == \"supergauss\":\n        # Slightly adjusted ranges to encourage exploration, focus on p slightly above 2\n        params = {\"type\":\"supergauss\", \"a\": random.uniform(0.7, 1.7), \"p\": random.uniform(2.1, 5.5)}\n    elif choice == \"lorentz\":\n        # Slightly adjusted range for b, keep it positive\n        params = {\"type\":\"lorentz\", \"b\": random.uniform(0.5, 2.0)}\n    else:\n        # Slightly adjusted ranges for a and r, ensure r is not too close to 0 or 1\n        params = {\"type\":\"mixed\", \"a\": random.uniform(0.5, 1.5), \"r\": random.uniform(0.35, 0.65)}\n    # OpenEvolve can mutate the `params` dict or replace it with other dicts. Return it.\n    return params\n```\nKey features: Performs well on error (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n# initial_program.py\nimport math\nimport random\n\n# Parametric family factory: returns a function f(x) built from parameters.\n# Candidate modules can either provide `params` (dict) or a function `f(x, **kwargs)`.\ndef build_parametric_f(params):\n    # params expected keys: \"type\" and numeric parameters\n    t = params.get(\"type\", \"supergauss\")\n    if t == \"supergauss\":\n        a = float(params.get(\"a\", 1.0))\n        p = float(params.get(\"p\", 4.0))   # p=2 is Gaussian, p>2 super-gauss\n        def f(x):\n            # Ensure a is not zero and p is not excessively large to prevent overflow\n            safe_a = max(a, 1e-9)\n            safe_p = min(p, 10.0) # Cap p to avoid potential overflow with large x\n            return math.exp(- (abs(x)/safe_a)**safe_p )\n        return f\n    elif t == \"lorentz\":\n        b = float(params.get(\"b\", 1.0))\n        # Ensure b is not zero to avoid division by zero\n        safe_b = max(b, 1e-9)\n        def f(x):\n            return 1.0 / (1.0 + (x/safe_b)**2)\n        return f\n    elif t == \"mixed\":\n        a = float(params.get(\"a\", 1.0))\n        r = float(params.get(\"r\", 0.5))\n        # Ensure a is not zero\n        safe_a = max(a, 1e-9)\n        def f(x):\n            # Ensure denominator in lorentz part is not zero\n            safe_lorentz_denom = max(1.0 + x*x, 1e-9)\n            return (1-r)*math.exp(-safe_a*x*x) + r/(safe_lorentz_denom)\n        return f\n    else:\n        # fallback safe Gaussian\n        a = float(params.get(\"a\", 1.0))\n        # Ensure a is not zero\n        safe_a = max(a, 1e-9)\n        def f(x):\n            return math.exp(-safe_a*x*x)\n        return f\n\n# This search_algorithm returns a small parameter dictionary.\ndef search_algorithm():\n    # Provide a diverse starting sample (avoid p=2 exactly to not be Gaussian-first)\n    seed_types = [\"supergauss\", \"lorentz\", \"mixed\"]\n    choice = random.choice(seed_types)\n    if choice == \"supergauss\":\n        # Slightly adjusted ranges to encourage exploration, with a cap on p\n        params = {\"type\":\"supergauss\", \"a\": random.uniform(0.7, 1.9), \"p\": random.uniform(3.0, 5.5)}\n    elif choice == \"lorentz\":\n        # Slightly adjusted range for b\n        params = {\"type\":\"lorentz\", \"b\": random.uniform(0.5, 2.8)}\n    else:\n        # Slightly adjusted ranges for a and r\n        params = {\"type\":\"mixed\", \"a\": random.uniform(0.5, 1.9), \"r\": random.uniform(0.35, 0.65)}\n    # OpenEvolve can mutate the `params` dict or replace it with other dicts. Return it.\n    return params\n```\nKey features: Alternative approach to error\n\n### Program D2 (Score: 0.0000)\n```python\n# initial_program.py\nimport math\nimport random\n\n# Parametric family factory: returns a function f(x) built from parameters.\n# Candidate modules can either provide `params` (dict) or a function `f(x, **kwargs)`.\ndef build_parametric_f(params):\n    # params expected keys: \"type\" and numeric parameters\n    t = params.get(\"type\", \"supergauss\")\n    if t == \"supergauss\":\n        a = float(params.get(\"a\", 1.0))\n        p = float(params.get(\"p\", 4.0))   # p=2 is Gaussian, p>2 super-gauss\n        def f(x):\n            # Ensure a is not zero to prevent division by zero\n            safe_a = max(a, 1e-9)\n            # Cap the exponent to prevent overflow for large x or large p\n            exponent = (abs(x)/safe_a)**p\n            return math.exp(-min(exponent, 700))\n        return f\n    elif t == \"lorentz\":\n        b = float(params.get(\"b\", 1.0))\n        # Ensure b is not zero to prevent division by zero\n        safe_b = max(b, 1e-9)\n        def f(x):\n            return 1.0 / (1.0 + (x/safe_b)**2)\n        return f\n    elif t == \"mixed\":\n        a = float(params.get(\"a\", 1.0))\n        r = float(params.get(\"r\", 0.5))\n        # Ensure a is not zero to prevent division by zero\n        safe_a = max(a, 1e-9)\n        def f(x):\n            # Cap the exponent to prevent overflow\n            gaussian_term = (1-r)*math.exp(-min(safe_a*x*x, 700))\n            lorentz_term = r/(1.0 + x*x)\n            return gaussian_term + lorentz_term\n        return f\n    else:\n        # fallback safe Gaussian\n        a = float(params.get(\"a\", 1.0))\n        # Ensure a is not zero to prevent division by zero\n        safe_a = max(a, 1e-9)\n        def f(x):\n            return math.exp(-safe_a*x*x)\n        return f\n\n# This search_algorithm returns a small parameter dictionary.\ndef search_algorithm():\n    # Provide a diverse starting sample (avoid p=2 exactly to not be Gaussian-first)\n    seed_types = [\"supergauss\", \"lorentz\", \"mixed\"]\n    choice = random.choice(seed_types)\n    if choice == \"supergauss\":\n        # Slightly adjusted ranges to encourage exploration, focus on p slightly above 2\n        params = {\"type\":\"supergauss\", \"a\": random.uniform(0.7, 1.7), \"p\": random.uniform(2.1, 5.5)}\n    elif choice == \"lorentz\":\n        # Slightly adjusted range for b, keep it positive\n        params = {\"type\":\"lorentz\", \"b\": random.uniform(0.5, 2.0)}\n    else:\n        # Slightly adjusted ranges for a and r, ensure r is not too close to 0 or 1\n        params = {\"type\":\"mixed\", \"a\": random.uniform(0.5, 1.5), \"r\": random.uniform(0.35, 0.65)}\n    # OpenEvolve can mutate the `params` dict or replace it with other dicts. Return it.\n    return params\n```\nKey features: Alternative approach to error\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\n# initial_program.py\nimport math\nimport random\n\n# Parametric family factory: returns a function f(x) built from parameters.\n# Candidate modules can either provide `params` (dict) or a function `f(x, **kwargs)`.\ndef build_parametric_f(params):\n    # params expected keys: \"type\" and numeric parameters\n    t = params.get(\"type\", \"supergauss\")\n    if t == \"supergauss\":\n        a = float(params.get(\"a\", 1.0))\n        p = float(params.get(\"p\", 4.0))   # p=2 is Gaussian, p>2 super-gauss\n        def f(x):\n            # Ensure a is not zero to prevent division by zero\n            safe_a = max(a, 1e-9)\n            # Ensure the exponent doesn't become too large for large x\n            exponent = (abs(x)/safe_a)**p\n            return math.exp(-min(exponent, 700)) # Cap exponent to avoid overflow\n        return f\n    elif t == \"lorentz\":\n        b = float(params.get(\"b\", 1.0))\n        # Ensure b is not zero to prevent division by zero\n        safe_b = max(b, 1e-9)\n        def f(x):\n            return 1.0 / (1.0 + (x/safe_b)**2)\n        return f\n    elif t == \"mixed\":\n        a = float(params.get(\"a\", 1.0))\n        r = float(params.get(\"r\", 0.5))\n        # Ensure a is not zero\n        safe_a = max(a, 1e-9)\n        def f(x):\n            # Ensure the exponent doesn't become too large for large x\n            gaussian_term = (1-r)*math.exp(-min(safe_a*x*x, 700))\n            lorentz_term = r/(1.0 + x*x)\n            return gaussian_term + lorentz_term\n        return f\n    else:\n        # fallback safe Gaussian\n        a = float(params.get(\"a\", 1.0))\n        # Ensure a is not zero\n        safe_a = max(a, 1e-9)\n        def f(x):\n            return math.exp(-safe_a*x*x)\n        return f\n\n# This search_algorithm returns a small parameter dictionary.\ndef search_algorithm():\n    # Provide a diverse starting sample (avoid p=2 exactly to not be Gaussian-first)\n    seed_types = [\"supergauss\", \"lorentz\", \"mixed\"]\n    choice = random.choice(seed_types)\n    if choice == \"supergauss\":\n        # Slightly adjusted ranges to encourage exploration, focus on p slightly above 2\n        params = {\"type\":\"supergauss\", \"a\": random.uniform(0.7, 1.7), \"p\": random.uniform(2.1, 5.5)}\n    elif choice == \"lorentz\":\n        # Slightly adjusted range for b, keep it positive\n        params = {\"type\":\"lorentz\", \"b\": random.uniform(0.5, 2.0)}\n    else:\n        # Slightly adjusted ranges for a and r, ensure r is not too close to 0 or 1\n        params = {\"type\":\"mixed\", \"a\": random.uniform(0.5, 1.5), \"r\": random.uniform(0.35, 0.65)}\n    # OpenEvolve can mutate the `params` dict or replace it with other dicts. Return it.\n    return params\n```\nUnique approach: Modification: Full rewrite, Alternative error approach, Comprehensive implementation\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\n# initial_program.py\nimport math\nimport random\n\n# Parametric family factory: returns a function f(x) built from parameters.\n# Candidate modules can either provide `params` (dict) or a function `f(x, **kwargs)`.\ndef build_parametric_f(params):\n    # params expected keys: \"type\" and numeric parameters\n    t = params.get(\"type\", \"supergauss\")\n    if t == \"supergauss\":\n        a = float(params.get(\"a\", 1.0))\n        p = float(params.get(\"p\", 4.0))   # p=2 is Gaussian, p>2 super-gauss\n        def f(x):\n            # Ensure a is not zero and p is not excessively large to prevent overflow\n            safe_a = max(a, 1e-9)\n            safe_p = min(p, 10.0) # Cap p to avoid potential overflow with large x\n            return math.exp(- (abs(x)/safe_a)**safe_p )\n        return f\n    elif t == \"lorentz\":\n        b = float(params.get(\"b\", 1.0))\n        # Ensure b is not zero to avoid division by zero\n        safe_b = max(b, 1e-9)\n        def f(x):\n            return 1.0 / (1.0 + (x/safe_b)**2)\n        return f\n    elif t == \"mixed\":\n        a = float(params.get(\"a\", 1.0))\n        r = float(params.get(\"r\", 0.5))\n        # Ensure a is not zero\n        safe_a = max(a, 1e-9)\n        def f(x):\n            # Ensure denominator in lorentz part is not zero\n            safe_lorentz_denom = max(1.0 + x*x, 1e-9)\n            return (1-r)*math.exp(-safe_a*x*x) + r/(safe_lorentz_denom)\n        return f\n    else:\n        # fallback safe Gaussian\n        a = float(params.get(\"a\", 1.0))\n        # Ensure a is not zero\n        safe_a = max(a, 1e-9)\n        def f(x):\n            return math.exp(-safe_a*x*x)\n        return f\n\n# This search_algorithm returns a small parameter dictionary.\ndef search_algorithm():\n    # Provide a diverse starting sample (avoid p=2 exactly to not be Gaussian-first)\n    seed_types = [\"supergauss\", \"lorentz\", \"mixed\"]\n    choice = random.choice(seed_types)\n    if choice == \"supergauss\":\n        # Slightly adjusted ranges to encourage exploration, with a cap on p\n        params = {\"type\":\"supergauss\", \"a\": random.uniform(0.7, 1.9), \"p\": random.uniform(3.0, 5.5)}\n    elif choice == \"lorentz\":\n        # Slightly adjusted range for b\n        params = {\"type\":\"lorentz\", \"b\": random.uniform(0.5, 2.8)}\n    else:\n        # Slightly adjusted ranges for a and r\n        params = {\"type\":\"mixed\", \"a\": random.uniform(0.5, 1.9), \"r\": random.uniform(0.35, 0.65)}\n    # OpenEvolve can mutate the `params` dict or replace it with other dicts. Return it.\n    return params\n```\nUnique approach: Modification: Full rewrite, Alternative error approach, Comprehensive implementation\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n# initial_program.py\nimport math\nimport random\n\n# Parametric family factory: returns a function f(x) built from parameters.\n# Candidate modules can either provide `params` (dict) or a function `f(x, **kwargs)`.\ndef build_parametric_f(params):\n    # params expected keys: \"type\" and numeric parameters\n    t = params.get(\"type\", \"supergauss\")\n    if t == \"supergauss\":\n        a = float(params.get(\"a\", 1.0))\n        p = float(params.get(\"p\", 4.0))   # p=2 is Gaussian, p>2 super-gauss\n        def f(x):\n            # Ensure a is not zero to avoid division by zero\n            if a == 0:\n                return 0.0\n            return math.exp(- (abs(x)/a)**p )\n        return f\n    elif t == \"lorentz\":\n        b = float(params.get(\"b\", 1.0))\n        def f(x):\n            # Ensure b is not zero to avoid division by zero\n            if b == 0:\n                return 0.0\n            return 1.0 / (1.0 + (x/b)**2)\n        return f\n    elif t == \"mixed\":\n        a = float(params.get(\"a\", 1.0))\n        r = float(params.get(\"r\", 0.5))\n        def f(x):\n            # Ensure a is not zero to avoid division by zero\n            if a == 0:\n                return r / (1.0 + x*x)\n            return (1-r)*math.exp(-a*x*x) + r/(1.0 + x*x)\n        return f\n    else:\n        # fallback safe Gaussian\n        a = float(params.get(\"a\", 1.0))\n        def f(x):\n            # Ensure a is not zero to avoid division by zero\n            if a == 0:\n                return 0.0\n            return math.exp(-a*x*x)\n        return f\n\n# This search_algorithm returns a small parameter dictionary.\ndef search_algorithm():\n    # Provide a diverse starting sample (avoid p=2 exactly to not be Gaussian-first)\n    seed_types = [\"supergauss\", \"lorentz\", \"mixed\"]\n    choice = random.choice(seed_types)\n    if choice == \"supergauss\":\n        # Mutate 'a' slightly and 'p' to a value slightly larger than 2\n        params = {\"type\":\"supergauss\", \"a\": random.uniform(0.5, 1.5), \"p\": random.uniform(2.1, 5.0)}\n    elif choice == \"lorentz\":\n        # Mutate 'b' slightly\n        params = {\"type\":\"lorentz\", \"b\": random.uniform(0.8, 2.5)}\n    else:\n        # Mutate 'a' and 'r' slightly\n        params = {\"type\":\"mixed\", \"a\": random.uniform(0.7, 1.8), \"r\": random.uniform(0.3, 0.7)}\n    # OpenEvolve can mutate the `params` dict or replace it with other dicts. Return it.\n    return params\n```\nUnique approach: Modification: Full rewrite, Alternative error approach, Comprehensive implementation\n\n# Current Program\n```python\n# initial_program.py\nimport math\nimport random\n\n# Parametric family factory: returns a function f(x) built from parameters.\n# Candidate modules can either provide `params` (dict) or a function `f(x, **kwargs)`.\ndef build_parametric_f(params):\n    # params expected keys: \"type\" and numeric parameters\n    t = params.get(\"type\", \"supergauss\")\n    if t == \"supergauss\":\n        a = float(params.get(\"a\", 1.0))\n        p = float(params.get(\"p\", 4.0))   # p=2 is Gaussian, p>2 super-gauss\n        def f(x):\n            # Ensure a is not zero to avoid division by zero, use max for numerical stability\n            safe_a = max(a, 1e-9)\n            return math.exp(- (abs(x)/safe_a)**p )\n        return f\n    elif t == \"lorentz\":\n        b = float(params.get(\"b\", 1.0))\n        # Ensure b is not zero to avoid division by zero, use max for numerical stability\n        safe_b = max(b, 1e-9)\n        def f(x):\n            return 1.0 / (1.0 + (x/safe_b)**2)\n        return f\n    elif t == \"mixed\":\n        a = float(params.get(\"a\", 1.0))\n        r = float(params.get(\"r\", 0.5))\n        # Ensure a is not zero to avoid division by zero, use max for numerical stability\n        safe_a = max(a, 1e-9)\n        def f(x):\n            # Ensure denominator in lorentz part is not zero, use max for numerical stability\n            safe_lorentz_denom = max(1.0 + x*x, 1e-9)\n            return (1-r)*math.exp(-safe_a*x*x) + r/(safe_lorentz_denom)\n        return f\n    else:\n        # fallback safe Gaussian\n        a = float(params.get(\"a\", 1.0))\n        # Ensure a is not zero to avoid division by zero, use max for numerical stability\n        safe_a = max(a, 1e-9)\n        def f(x):\n            return math.exp(-safe_a*x*x)\n        return f\n\n# This search_algorithm returns a small parameter dictionary.\ndef search_algorithm():\n    # Provide a diverse starting sample (avoid p=2 exactly to not be Gaussian-first)\n    seed_types = [\"supergauss\", \"lorentz\", \"mixed\"]\n    choice = random.choice(seed_types)\n    if choice == \"supergauss\":\n        # Mutate 'a' slightly and 'p' to a value slightly larger than 2\n        params = {\"type\":\"supergauss\", \"a\": random.uniform(0.7, 1.3), \"p\": random.uniform(2.1, 5.0)}\n    elif choice == \"lorentz\":\n        # Mutate 'b' slightly\n        params = {\"type\":\"lorentz\", \"b\": random.uniform(0.7, 1.3)}\n    else:\n        # Mutate 'a' and 'r' slightly\n        params = {\"type\":\"mixed\", \"a\": random.uniform(0.7, 1.3), \"r\": random.uniform(0.4, 0.6)}\n    # OpenEvolve can mutate the `params` dict or replace it with other dicts. Return it.\n    return params\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# initial_program.py\nimport math\nimport random\n\n# Parametric family factory: returns a function f(x) built from parameters.\n# Candidate modules can either provide `params` (dict) or a function `f(x, **kwargs)`.\ndef build_parametric_f(params):\n    # params expected keys: \"type\" and numeric parameters\n    t = params.get(\"type\", \"supergauss\")\n    if t == \"supergauss\":\n        a = float(params.get(\"a\", 1.0))\n        p = float(params.get(\"p\", 4.0))   # p=2 is Gaussian, p>2 super-gauss\n        def f(x):\n            # Ensure a is not zero to avoid division by zero, use max for numerical stability\n            safe_a = max(a, 1e-9)\n            # Cap the exponent to prevent overflow for large x or large p\n            exponent = (abs(x)/safe_a)**p\n            return math.exp(-min(exponent, 700))\n        return f\n    elif t == \"lorentz\":\n        b = float(params.get(\"b\", 1.0))\n        # Ensure b is not zero to avoid division by zero, use max for numerical stability\n        safe_b = max(b, 1e-9)\n        def f(x):\n            return 1.0 / (1.0 + (x/safe_b)**2)\n        return f\n    elif t == \"mixed\":\n        a = float(params.get(\"a\", 1.0))\n        r = float(params.get(\"r\", 0.5))\n        # Ensure a is not zero to avoid division by zero, use max for numerical stability\n        safe_a = max(a, 1e-9)\n        def f(x):\n            # Ensure denominator in lorentz part is not zero, use max for numerical stability\n            safe_lorentz_denom = max(1.0 + x*x, 1e-9)\n            # Cap the exponent to prevent overflow\n            gaussian_term = (1-r)*math.exp(-min(safe_a*x*x, 700))\n            return gaussian_term + r/(safe_lorentz_denom)\n        return f\n    else:\n        # fallback safe Gaussian\n        a = float(params.get(\"a\", 1.0))\n        # Ensure a is not zero to avoid division by zero, use max for numerical stability\n        safe_a = max(a, 1e-9)\n        def f(x):\n            return math.exp(-safe_a*x*x)\n        return f\n\n# This search_algorithm returns a small parameter dictionary.\ndef search_algorithm():\n    # Provide a diverse starting sample (avoid p=2 exactly to not be Gaussian-first)\n    seed_types = [\"supergauss\", \"lorentz\", \"mixed\"]\n    choice = random.choice(seed_types)\n    if choice == \"supergauss\":\n        # Mutate 'a' slightly and 'p' to a value slightly larger than 2, with a focus on p > 2\n        params = {\"type\":\"supergauss\", \"a\": random.uniform(0.8, 1.2), \"p\": random.uniform(2.2, 4.8)}\n    elif choice == \"lorentz\":\n        # Mutate 'b' slightly, ensuring it remains positive and not too close to zero\n        params = {\"type\":\"lorentz\", \"b\": random.uniform(0.8, 1.2)}\n    else:\n        # Mutate 'a' and 'r' slightly, ensuring 'r' is not too close to 0 or 1\n        params = {\"type\":\"mixed\", \"a\": random.uniform(0.8, 1.2), \"r\": random.uniform(0.45, 0.55)}\n    # OpenEvolve can mutate the `params` dict or replace it with other dicts. Return it.\n    return params\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}